services:
  rust:
    build:
      context: ./rust
      dockerfile: Dockerfile
      args:
        BUILD_ENV: ${BUILD_ENV}
    image: rust-app-${BUILD_ENV}
    env_file:
      - .env
      - ./blazing_sun/.env
    environment:
      - PORT=${APP_PORT}
      - POSTGRES_IP=${POSTGRES_IP}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - RABBITMQ_HOST=${RABBITMQ_HOST}
      - RABBITMQ_PORT=${RABBITMQ_PORT}
      - RABBITMQ_USER=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD}
      - RABBITMQ_VHOST=${RABBITMQ_VHOST}
      - KAFKA_HOST=${KAFKA_HOST}
      - KAFKA_PORT=${KAFKA_PORT}
      - REDIS_IP=${REDIS_IP}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDIS_DB=${REDIS_DB}
      - MONGO_HOST=${MONGO_HOST}
      - MONGO_PORT=${MONGO_PORT}
      - MONGO_USER=${MONGO_USER}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_INITDB_DATABASE}
      # Storage configuration (files go to storage/app inside container)
      - UPLOAD_STORAGE_PATH=${UPLOAD_STORAGE_PATH}
      - STORAGE_DRIVER=local
      - STORAGE_PUBLIC_URL=/storage
      - STORAGE_PRIVATE_URL=/api/v1/upload/private
      # Session configuration
      - SESSION_DRIVER=${SESSION_DRIVER}
      - SESSION_REDIS_URL=${SESSION_REDIS_URL}
      - SESSION_COOKIE=${SESSION_COOKIE}
      - SESSION_LIFETIME_MINUTES=${SESSION_LIFETIME_MINUTES}
      - SESSION_REFRESH_TTL=${SESSION_REFRESH_TTL}
      - SESSION_REGENERATE_ON_LOGIN=${SESSION_REGENERATE_ON_LOGIN}
      - SESSION_SECURE_COOKIE=${SESSION_SECURE_COOKIE}
      - SESSION_HTTP_ONLY=${SESSION_HTTP_ONLY}
      - SESSION_SAMESITE=${SESSION_SAMESITE}
      - SESSION_COOKIE_PATH=${SESSION_COOKIE_PATH}
      - SESSION_KEY_PREFIX=${SESSION_KEY_PREFIX}
      - SESSION_SECRET_KEY=${SESSION_SECRET_KEY}
    volumes:
      - ./blazing_sun:/home/rust/blazing_sun
      - cargo-cache:/usr/local/cargo/registry
      - target-cache:/home/rust/blazing_sun/target
    working_dir: /home/rust/blazing_sun
    tty: true
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      kafka:
        condition: service_healthy
      redis:
        condition: service_healthy
      mongo:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: 172.28.0.10

  checkout:
    build:
      context: ./checkout
      dockerfile: Dockerfile
      args:
        BUILD_ENV: ${BUILD_ENV}
    image: checkout-${BUILD_ENV}
    env_file:
      - .env
      - ./checkout/.env
    environment:
      - BUILD_ENV=${BUILD_ENV}
      - CHECKOUT_HOST=0.0.0.0
      - CHECKOUT_PORT=${CHECKOUT_PORT:-9996}
      - CHECKOUT_KAFKA_GROUP=checkout-service
      - KAFKA_HOST=${KAFKA_HOST}
      - KAFKA_PORT=${KAFKA_PORT}
      - CHECKOUT_DB_HOST=${CHECKOUT_POSTGRES_HOST}
      - CHECKOUT_DB_PORT=${CHECKOUT_POSTGRES_PORT}
      - CHECKOUT_DB_USER=${CHECKOUT_POSTGRES_USER}
      - CHECKOUT_DB_PASSWORD=${CHECKOUT_POSTGRES_PASSWORD}
      - CHECKOUT_DB_NAME=${CHECKOUT_POSTGRES_DB}
      - RUST_LOG=info,checkout=debug
    volumes:
      - ./checkout:/home/rust/checkout
      - checkout-cargo-cache:/usr/local/cargo/registry
      - checkout-target-cache:/home/rust/checkout/target
    working_dir: /home/rust/checkout
    ports:
      - "${CHECKOUT_PORT:-9996}:${CHECKOUT_PORT:-9996}"
    restart: unless-stopped
    depends_on:
      kafka:
        condition: service_healthy
      checkout-postgres:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${CHECKOUT_PORT:-9996}/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: ${CHECKOUT_IP:-172.28.0.24}

  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    image: nginx-ssl
    ports:
      - "0.0.0.0:80:80"
      - "0.0.0.0:443:443/tcp"
      - "0.0.0.0:443:443/udp"
    environment:
      - APP_PORT=${APP_PORT}
    volumes:
      # Mount public storage for static file serving (src/storage/app/public)
      - ./blazing_sun/src/storage/app/public:/var/www/storage/public:ro
      # Mount assets (CSS/JS) for templates
      - ./blazing_sun/src/resources/css:/var/www/assets/css:ro
      - ./blazing_sun/src/resources/js:/var/www/assets/js:ro
      # Mount localization JSON files
      - ./blazing_sun/src/resources/localization:/var/www/localizations:ro
    restart: unless-stopped
    depends_on:
      - rust
    networks:
      devnet:
        ipv4_address: 172.28.0.12

  php-oauth:
    build:
      context: ./php-oauth
      dockerfile: Dockerfile
    image: php-oauth-test
    ports:
      - "0.0.0.0:8889:443"
    environment:
      - OAUTH_CLIENT_ID=${OAUTH_CLIENT_ID}
      - OAUTH_CLIENT_SECRET=${OAUTH_CLIENT_SECRET}
      - OAUTH_CODE_VERIFIER=${OAUTH_CODE_VERIFIER}
      - OAUTH_TOKEN_URL=${OAUTH_TOKEN_URL}
      - OAUTH_REDIRECT_URI=${OAUTH_REDIRECT_URI}
    volumes:
      - ./php-oauth/src:/var/www/html
    restart: unless-stopped
    depends_on:
      - nginx
    networks:
      devnet:
        ipv4_address: 172.28.0.22

  postgres:
    build:
      context: ./postgres
      dockerfile: Dockerfile
      args:
        POSTGRES_IP: ${POSTGRES_IP}
        POSTGRES_PORT: ${POSTGRES_PORT}
        POSTGRES_USER: ${POSTGRES_USER}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
        POSTGRES_DB: ${POSTGRES_DB}
    image: postgres-ssl
    env_file:
      - .env
    environment:
      - POSTGRES_IP=${POSTGRES_IP}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - pgdata:/var/lib/postgresql
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      devnet:
        ipv4_address: ${POSTGRES_IP}

  checkout-postgres:
    build:
      context: ./postgres_checkout
      dockerfile: Dockerfile
      args:
        POSTGRES_IP: ${CHECKOUT_POSTGRES_IP}
        POSTGRES_PORT: ${CHECKOUT_POSTGRES_PORT}
        POSTGRES_USER: ${CHECKOUT_POSTGRES_USER}
        POSTGRES_PASSWORD: ${CHECKOUT_POSTGRES_PASSWORD}
        POSTGRES_DB: ${CHECKOUT_POSTGRES_DB}
    image: checkout-postgres-ssl
    env_file:
      - .env
    environment:
      - POSTGRES_IP=${CHECKOUT_POSTGRES_IP}
      - POSTGRES_PORT=${CHECKOUT_POSTGRES_PORT}
      - POSTGRES_USER=${CHECKOUT_POSTGRES_USER}
      - POSTGRES_PASSWORD=${CHECKOUT_POSTGRES_PASSWORD}
      - POSTGRES_DB=${CHECKOUT_POSTGRES_DB}
    volumes:
      - checkout-pgdata:/var/lib/postgresql
    ports:
      - "${CHECKOUT_POSTGRES_PORT}:${CHECKOUT_POSTGRES_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${CHECKOUT_POSTGRES_USER} -d ${CHECKOUT_POSTGRES_DB} -p ${CHECKOUT_POSTGRES_PORT}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      devnet:
        ipv4_address: ${CHECKOUT_POSTGRES_IP}

  rabbitmq:
    build:
      context: ./rabbitmq
      dockerfile: Dockerfile
      args:
        RABBITMQ_USER: ${RABBITMQ_USER}
        RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD}
        RABBITMQ_VHOST: ${RABBITMQ_VHOST}
        RABBITMQ_PORT: ${RABBITMQ_PORT}
        RABBITMQ_MANAGEMENT_PORT: ${RABBITMQ_MANAGEMENT_PORT}
    image: rabbitmq-mq
    hostname: rabbitmq
    ulimits:
      nofile:
        soft: 65536
        hard: 65536
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
      - RABBITMQ_DEFAULT_VHOST=${RABBITMQ_VHOST}
      - RABBITMQ_USER=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD}
      - RABBITMQ_VHOST=${RABBITMQ_VHOST}
      - RABBITMQ_PORT=${RABBITMQ_PORT}
      - RABBITMQ_MANAGEMENT_PORT=${RABBITMQ_MANAGEMENT_PORT}
    volumes:
      - rabbitmqdata:/var/lib/rabbitmq
    ports:
      - "${RABBITMQ_PORT}:${RABBITMQ_PORT}"
      - "${RABBITMQ_MANAGEMENT_PORT}:${RABBITMQ_MANAGEMENT_PORT}"
      - "15692:15692"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: 172.28.0.14

  redis:
    build:
      context: ./redis
      dockerfile: Dockerfile
      args:
        REDIS_IP: ${REDIS_IP}
        REDIS_PASSWORD: ${REDIS_PASSWORD}
        REDIS_USER: ${REDIS_USER}
        REDIS_PORT: ${REDIS_PORT}
        REDIS_DB: ${REDIS_DB}
    image: redis-pubsub
    environment:
      - REDIS_IP=${REDIS_IP}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDIS_USER=${REDIS_USER}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_DB=${REDIS_DB}
    volumes:
      - redisdata:/data
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 5s
    networks:
      devnet:
        ipv4_address: ${REDIS_IP}

  kafka:
    build:
      context: ./kafka
      dockerfile: Dockerfile
      args:
        KAFKA_BROKER_ID: ${KAFKA_BROKER_ID}
        KAFKA_PORT: ${KAFKA_PORT}
        KAFKA_CONTROLLER_PORT: ${KAFKA_CONTROLLER_PORT}
    image: kafka-events
    pull_policy: build
    hostname: kafka
    environment:
      - KAFKA_NODE_ID=${KAFKA_BROKER_ID}
      - KAFKA_PROCESS_ROLES=broker,controller
      - KAFKA_CONTROLLER_QUORUM_VOTERS=${KAFKA_BROKER_ID}@kafka:${KAFKA_CONTROLLER_PORT}
      - KAFKA_LISTENERS=PLAINTEXT://:${KAFKA_PORT},CONTROLLER://:${KAFKA_CONTROLLER_PORT}
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:${KAFKA_PORT}
      - KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_INTER_BROKER_LISTENER_NAME=PLAINTEXT
      - KAFKA_AUTO_CREATE_TOPICS_ENABLE=true
      - KAFKA_NUM_PARTITIONS=${KAFKA_NUM_PARTITIONS}
      - KAFKA_DEFAULT_REPLICATION_FACTOR=1
      - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      - KAFKA_TRANSACTION_STATE_LOG_MIN_ISR=1
      - KAFKA_LOG_RETENTION_HOURS=${KAFKA_LOG_RETENTION_HOURS}
      - CLUSTER_ID=${KAFKA_CLUSTER_ID}
    volumes:
      - kafkadata:/var/lib/kafka/data
    ports:
      - "${KAFKA_PORT}:${KAFKA_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "/usr/local/bin/kafka-healthcheck.sh"]
      interval: 10s
      timeout: 10s
      retries: 10
      start_period: 40s
    networks:
      devnet:
        ipv4_address: ${KAFKA_IP}

  kafka-ui:
    build:
      context: ./kafka-ui
      dockerfile: Dockerfile
    image: kafka-ui-dashboard
    hostname: kafka-ui
    environment:
      - KAFKA_CLUSTERS_0_NAME=${KAFKA_UI_CLUSTER_NAME}
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=${KAFKA_HOST}:${KAFKA_PORT}
      - SERVER_SERVLET_CONTEXT_PATH=/kafka
      # Authentication
      - AUTH_TYPE=LOGIN_FORM
      - SPRING_SECURITY_USER_NAME=${KAFKA_UI_USER}
      - SPRING_SECURITY_USER_PASSWORD=${KAFKA_UI_PASSWORD}
    ports:
      - "${KAFKA_UI_PORT}:8080"
    restart: unless-stopped
    depends_on:
      kafka:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: ${KAFKA_UI_IP}

  pgadmin:
    build:
      context: ./pgadmin
      dockerfile: Dockerfile
      args:
        PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
        PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    image: pgadmin-dashboard
    pull_policy: build
    hostname: pgadmin
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
      - SCRIPT_NAME=/pgadmin
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - pgadmindata:/var/lib/pgadmin
    ports:
      - "${PGADMIN_PORT}:80"
    restart: unless-stopped
    depends_on:
      - postgres
    networks:
      devnet:
        ipv4_address: ${PGADMIN_IP}

  pgadmin_checkout:
    build:
      context: ./pgadmin_checkout
      dockerfile: Dockerfile
      args:
        PGADMIN_DEFAULT_EMAIL: ${PGADMIN_CHECKOUT_DEFAULT_EMAIL}
        PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_CHECKOUT_DEFAULT_PASSWORD}
    image: pgadmin-checkout-dashboard
    pull_policy: build
    hostname: pgadmin_checkout
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_CHECKOUT_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_CHECKOUT_DEFAULT_PASSWORD}
      - SCRIPT_NAME=/pgadmin_checkout
      - POSTGRES_HOST=${CHECKOUT_POSTGRES_HOST}
      - POSTGRES_PORT=${CHECKOUT_POSTGRES_PORT}
      - POSTGRES_USER=${CHECKOUT_POSTGRES_USER}
      - POSTGRES_PASSWORD=${CHECKOUT_POSTGRES_PASSWORD}
    volumes:
      - pgadmin-checkout-data:/var/lib/pgadmin
    ports:
      - "${PGADMIN_CHECKOUT_PORT}:80"
    restart: unless-stopped
    depends_on:
      - checkout-postgres
    networks:
      devnet:
        ipv4_address: ${PGADMIN_CHECKOUT_IP}

  prometheus:
    build:
      context: ./prometheus
      dockerfile: Dockerfile
    image: prometheus-monitoring
    volumes:
      - prometheusdata:/prometheus
    ports:
      - "9090:9090"
    restart: unless-stopped
    depends_on:
      - rabbitmq
    networks:
      devnet:
        ipv4_address: 172.28.0.15

  grafana:
    build:
      context: ./grafana
      dockerfile: Dockerfile
    image: grafana-monitoring
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_SERVER_ROOT_URL=https://local.rust.com/grafana/
      - GF_SERVER_SERVE_FROM_SUB_PATH=true
      - GF_SERVER_ENFORCE_DOMAIN=false
    volumes:
      - grafanadata:/var/lib/grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    depends_on:
      - prometheus
    networks:
      devnet:
        ipv4_address: 172.28.0.16

  mongo:
    build:
      context: ./mongo
      dockerfile: Dockerfile
      args:
        MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}
        MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}
        MONGO_INITDB_DATABASE: ${MONGO_INITDB_DATABASE}
        MONGO_USER: ${MONGO_USER}
        MONGO_PASSWORD: ${MONGO_PASSWORD}
        MONGO_PORT: ${MONGO_PORT}
    image: mongo-db
    pull_policy: build
    hostname: mongo
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_INITDB_DATABASE}
      - MONGO_USER=${MONGO_USER}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_PORT=${MONGO_PORT}
    volumes:
      - mongodata:/data/db
      - ./mongo/mongod.conf.template:/etc/mongo/mongod.conf.template:ro
    ports:
      - "${MONGO_PORT}:${MONGO_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')", "--quiet"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: ${MONGO_IP}

  mongo-express:
    build:
      context: ./mongo-express
      dockerfile: Dockerfile
    image: mongo-express-ui
    pull_policy: build
    hostname: mongo-express
    environment:
      - ME_CONFIG_MONGODB_ADMINUSERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - ME_CONFIG_MONGODB_ADMINPASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
      - ME_CONFIG_MONGODB_SERVER=${MONGO_HOST}
      - ME_CONFIG_MONGODB_PORT=${MONGO_PORT}
      - ME_CONFIG_BASICAUTH_USERNAME=${MONGO_EXPRESS_USER}
      - ME_CONFIG_BASICAUTH_PASSWORD=${MONGO_EXPRESS_PASSWORD}
      - ME_CONFIG_SITE_BASEURL=/mongo/
    ports:
      - "${MONGO_EXPRESS_PORT}:8081"
    restart: unless-stopped
    depends_on:
      mongo:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: ${MONGO_EXPRESS_IP}

  ws_gateway:
    build:
      context: ./ws_gateway
      dockerfile: Dockerfile
      args:
        BUILD_ENV: ${BUILD_ENV}
    image: ws-gateway-${BUILD_ENV}
    env_file:
      - .env
    environment:
      - BUILD_ENV=${BUILD_ENV}
      - WS_HOST=0.0.0.0
      - WS_PORT=${WS_GATEWAY_PORT:-9998}
      - WS_HEALTH_PORT=${WS_GATEWAY_HEALTH_PORT:-9997}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDIS_DB=${REDIS_DB}
      - KAFKA_HOST=${KAFKA_HOST}
      - KAFKA_PORT=${KAFKA_PORT}
      - KAFKA_CONSUMER_GROUP=ws_gateway
      - JWT_PUBLIC_KEY_PATH=/keys/jwt_public.pem
      - RUST_LOG=info,ws_gateway=debug
    volumes:
      - ./ws_gateway:/home/rust/ws_gateway
      - ./blazing_sun/keys:/keys:ro
      - ws-gateway-cargo-cache:/usr/local/cargo/registry
      - ws-gateway-target-cache:/home/rust/ws_gateway/target
    working_dir: /home/rust/ws_gateway
    ports:
      - "${WS_GATEWAY_PORT:-9998}:${WS_GATEWAY_PORT:-9998}"
      - "${WS_GATEWAY_HEALTH_PORT:-9997}:${WS_GATEWAY_HEALTH_PORT:-9997}"
    restart: unless-stopped
    depends_on:
      kafka:
        condition: service_healthy
      redis:
        condition: service_healthy
    healthcheck:
      test: ["CMD-SHELL", "curl -f http://localhost:${WS_GATEWAY_HEALTH_PORT:-9997}/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: ${WS_GATEWAY_IP:-172.28.0.23}

volumes:
  pgdata:
  checkout-pgdata:
  rabbitmqdata:
  redisdata:
  kafkadata:
  cargo-cache:
  target-cache:
  prometheusdata:
  grafanadata:
  pgadmindata:
  pgadmin-checkout-data:
  mongodata:
  ws-gateway-cargo-cache:
  ws-gateway-target-cache:
  checkout-cargo-cache:
  checkout-target-cache:

networks:
  devnet:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16
