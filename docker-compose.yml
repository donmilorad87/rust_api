services:
  rust:
    build:
      context: ./rust
      dockerfile: Dockerfile
      args:
        BUILD_ENV: ${BUILD_ENV}
    image: rust-app-${BUILD_ENV}
    env_file:
      - .env
      - ./money_flow/.env
    environment:
      - PORT=${APP_PORT}
      - POSTGRES_IP=${POSTGRES_IP}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - RABBITMQ_HOST=${RABBITMQ_HOST}
      - RABBITMQ_PORT=${RABBITMQ_PORT}
      - RABBITMQ_USER=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD}
      - RABBITMQ_VHOST=${RABBITMQ_VHOST}
      - KAFKA_HOST=${KAFKA_HOST}
      - KAFKA_PORT=${KAFKA_PORT}
      - REDIS_IP=${REDIS_IP}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_USER=${REDIS_USER}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDIS_DB=${REDIS_DB}
      - MONGO_HOST=${MONGO_HOST}
      - MONGO_PORT=${MONGO_PORT}
      - MONGO_USER=${MONGO_USER}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_INITDB_DATABASE}
      # Storage configuration (files go to src/storage/app)
      - UPLOAD_STORAGE_PATH=src/storage/app
      - STORAGE_DRIVER=local
      - STORAGE_PUBLIC_URL=/storage
      - STORAGE_PRIVATE_URL=/api/v1/upload/private
    volumes:
      - ./money_flow:/home/rust/money_flow
      - cargo-cache:/usr/local/cargo/registry
      - target-cache:/home/rust/money_flow/target
    working_dir: /home/rust/money_flow
    tty: true
    restart: unless-stopped
    depends_on:
      postgres:
        condition: service_healthy
      rabbitmq:
        condition: service_healthy
      kafka:
        condition: service_healthy
      redis:
        condition: service_healthy
      mongo:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: 172.28.0.10

  nginx:
    build:
      context: ./nginx
      dockerfile: Dockerfile
    image: nginx-ssl
    ports:
      - "0.0.0.0:80:80"
      - "0.0.0.0:443:443/tcp"
      - "0.0.0.0:443:443/udp"
    environment:
      - APP_PORT=${APP_PORT}
    volumes:
      # Mount public storage for static file serving (src/storage/app/public)
      - ./money_flow/src/storage/app/public:/var/www/storage/public:ro
      # Mount assets (CSS/JS) for templates
      - ./money_flow/src/resources/css:/var/www/assets/css:ro
      - ./money_flow/src/resources/js:/var/www/assets/js:ro
    restart: unless-stopped
    depends_on:
      - rust
    networks:
      devnet:
        ipv4_address: 172.28.0.12

  postgres:
    build:
      context: ./postgres
      dockerfile: Dockerfile
      args:
        POSTGRES_IP: ${POSTGRES_IP}
        POSTGRES_PORT: ${POSTGRES_PORT}
        POSTGRES_USER: ${POSTGRES_USER}
        POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
        POSTGRES_DB: ${POSTGRES_DB}
    image: postgres-ssl
    env_file:
      - .env
    environment:
      - POSTGRES_IP=${POSTGRES_IP}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    volumes:
      - pgdata:/var/lib/postgresql
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB}"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 10s
    networks:
      devnet:
        ipv4_address: ${POSTGRES_IP}

  rabbitmq:
    build:
      context: ./rabbitmq
      dockerfile: Dockerfile
      args:
        RABBITMQ_USER: ${RABBITMQ_USER}
        RABBITMQ_PASSWORD: ${RABBITMQ_PASSWORD}
        RABBITMQ_VHOST: ${RABBITMQ_VHOST}
        RABBITMQ_PORT: ${RABBITMQ_PORT}
        RABBITMQ_MANAGEMENT_PORT: ${RABBITMQ_MANAGEMENT_PORT}
    image: rabbitmq-mq
    hostname: rabbitmq
    ulimits:
      nofile:
        soft: 65536
        hard: 65536
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_PASSWORD}
      - RABBITMQ_DEFAULT_VHOST=${RABBITMQ_VHOST}
      - RABBITMQ_USER=${RABBITMQ_USER}
      - RABBITMQ_PASSWORD=${RABBITMQ_PASSWORD}
      - RABBITMQ_VHOST=${RABBITMQ_VHOST}
      - RABBITMQ_PORT=${RABBITMQ_PORT}
      - RABBITMQ_MANAGEMENT_PORT=${RABBITMQ_MANAGEMENT_PORT}
    volumes:
      - rabbitmqdata:/var/lib/rabbitmq
    ports:
      - "${RABBITMQ_PORT}:${RABBITMQ_PORT}"
      - "${RABBITMQ_MANAGEMENT_PORT}:${RABBITMQ_MANAGEMENT_PORT}"
      - "15692:15692"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "rabbitmq-diagnostics", "-q", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: 172.28.0.14

  redis:
    build:
      context: ./redis
      dockerfile: Dockerfile
      args:
        REDIS_IP: ${REDIS_IP}
        REDIS_PASSWORD: ${REDIS_PASSWORD}
        REDIS_USER: ${REDIS_USER}
        REDIS_PORT: ${REDIS_PORT}
        REDIS_DB: ${REDIS_DB}
    image: redis-pubsub
    environment:
      - REDIS_IP=${REDIS_IP}
      - REDIS_PASSWORD=${REDIS_PASSWORD}
      - REDIS_USER=${REDIS_USER}
      - REDIS_PORT=${REDIS_PORT}
      - REDIS_DB=${REDIS_DB}
    volumes:
      - redisdata:/data
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "-a", "${REDIS_PASSWORD}", "ping"]
      interval: 5s
      timeout: 5s
      retries: 5
      start_period: 5s
    networks:
      devnet:
        ipv4_address: ${REDIS_IP}

  kafka:
    build:
      context: ./kafka
      dockerfile: Dockerfile
      args:
        KAFKA_BROKER_ID: ${KAFKA_BROKER_ID}
        KAFKA_PORT: ${KAFKA_PORT}
        KAFKA_CONTROLLER_PORT: ${KAFKA_CONTROLLER_PORT}
    image: kafka-events
    pull_policy: build
    hostname: kafka
    environment:
      - KAFKA_NODE_ID=${KAFKA_BROKER_ID}
      - KAFKA_PROCESS_ROLES=broker,controller
      - KAFKA_CONTROLLER_QUORUM_VOTERS=${KAFKA_BROKER_ID}@kafka:${KAFKA_CONTROLLER_PORT}
      - KAFKA_LISTENERS=PLAINTEXT://:${KAFKA_PORT},CONTROLLER://:${KAFKA_CONTROLLER_PORT}
      - KAFKA_ADVERTISED_LISTENERS=PLAINTEXT://kafka:${KAFKA_PORT}
      - KAFKA_LISTENER_SECURITY_PROTOCOL_MAP=CONTROLLER:PLAINTEXT,PLAINTEXT:PLAINTEXT
      - KAFKA_CONTROLLER_LISTENER_NAMES=CONTROLLER
      - KAFKA_INTER_BROKER_LISTENER_NAME=PLAINTEXT
      - KAFKA_AUTO_CREATE_TOPICS_ENABLE=true
      - KAFKA_NUM_PARTITIONS=${KAFKA_NUM_PARTITIONS}
      - KAFKA_DEFAULT_REPLICATION_FACTOR=1
      - KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR=1
      - KAFKA_TRANSACTION_STATE_LOG_REPLICATION_FACTOR=1
      - KAFKA_TRANSACTION_STATE_LOG_MIN_ISR=1
      - KAFKA_LOG_RETENTION_HOURS=${KAFKA_LOG_RETENTION_HOURS}
      - CLUSTER_ID=${KAFKA_CLUSTER_ID}
    volumes:
      - kafkadata:/var/lib/kafka/data
    ports:
      - "${KAFKA_PORT}:${KAFKA_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "/opt/kafka/bin/kafka-broker-api-versions.sh --bootstrap-server localhost:${KAFKA_PORT} && /opt/kafka/bin/kafka-topics.sh --list --bootstrap-server localhost:${KAFKA_PORT} | grep -q 'user.events'"]
      interval: 10s
      timeout: 10s
      retries: 10
      start_period: 40s
    networks:
      devnet:
        ipv4_address: ${KAFKA_IP}

  kafka-ui:
    build:
      context: ./kafka-ui
      dockerfile: Dockerfile
    image: kafka-ui-dashboard
    hostname: kafka-ui
    environment:
      - KAFKA_CLUSTERS_0_NAME=${KAFKA_UI_CLUSTER_NAME}
      - KAFKA_CLUSTERS_0_BOOTSTRAPSERVERS=${KAFKA_HOST}:${KAFKA_PORT}
      - SERVER_SERVLET_CONTEXT_PATH=/kafka
      # Authentication
      - AUTH_TYPE=LOGIN_FORM
      - SPRING_SECURITY_USER_NAME=${KAFKA_UI_USER}
      - SPRING_SECURITY_USER_PASSWORD=${KAFKA_UI_PASSWORD}
    ports:
      - "${KAFKA_UI_PORT}:8080"
    restart: unless-stopped
    depends_on:
      kafka:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: ${KAFKA_UI_IP}

  pgadmin:
    build:
      context: ./pgadmin
      dockerfile: Dockerfile
      args:
        PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
        PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    image: pgadmin-dashboard
    pull_policy: build
    hostname: pgadmin
    environment:
      - PGADMIN_DEFAULT_EMAIL=${PGADMIN_DEFAULT_EMAIL}
      - PGADMIN_DEFAULT_PASSWORD=${PGADMIN_DEFAULT_PASSWORD}
      - SCRIPT_NAME=/pgadmin
      - POSTGRES_HOST=${POSTGRES_HOST}
      - POSTGRES_PORT=${POSTGRES_PORT}
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - pgadmindata:/var/lib/pgadmin
    ports:
      - "${PGADMIN_PORT}:80"
    restart: unless-stopped
    depends_on:
      - postgres
    networks:
      devnet:
        ipv4_address: ${PGADMIN_IP}

  prometheus:
    build:
      context: ./prometheus
      dockerfile: Dockerfile
    image: prometheus-monitoring
    volumes:
      - prometheusdata:/prometheus
    ports:
      - "9090:9090"
    restart: unless-stopped
    depends_on:
      - rabbitmq
    networks:
      devnet:
        ipv4_address: 172.28.0.15

  grafana:
    build:
      context: ./grafana
      dockerfile: Dockerfile
    image: grafana-monitoring
    environment:
      - GF_SECURITY_ADMIN_USER=${GRAFANA_USER:-admin}
      - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD:-admin}
      - GF_USERS_ALLOW_SIGN_UP=false
      - GF_SERVER_ROOT_URL=https://local.rust.com/grafana/
      - GF_SERVER_SERVE_FROM_SUB_PATH=true
      - GF_SERVER_ENFORCE_DOMAIN=false
    volumes:
      - grafanadata:/var/lib/grafana
    ports:
      - "3000:3000"
    restart: unless-stopped
    depends_on:
      - prometheus
    networks:
      devnet:
        ipv4_address: 172.28.0.16

  mongo:
    build:
      context: ./mongo
      dockerfile: Dockerfile
      args:
        MONGO_INITDB_ROOT_USERNAME: ${MONGO_INITDB_ROOT_USERNAME}
        MONGO_INITDB_ROOT_PASSWORD: ${MONGO_INITDB_ROOT_PASSWORD}
        MONGO_INITDB_DATABASE: ${MONGO_INITDB_DATABASE}
        MONGO_USER: ${MONGO_USER}
        MONGO_PASSWORD: ${MONGO_PASSWORD}
        MONGO_PORT: ${MONGO_PORT}
    image: mongo-db
    pull_policy: build
    hostname: mongo
    environment:
      - MONGO_INITDB_ROOT_USERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - MONGO_INITDB_ROOT_PASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
      - MONGO_INITDB_DATABASE=${MONGO_INITDB_DATABASE}
      - MONGO_USER=${MONGO_USER}
      - MONGO_PASSWORD=${MONGO_PASSWORD}
      - MONGO_PORT=${MONGO_PORT}
    volumes:
      - mongodata:/data/db
      - ./mongo/mongod.conf.template:/etc/mongo/mongod.conf.template:ro
    ports:
      - "${MONGO_PORT}:${MONGO_PORT}"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')", "--quiet"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    networks:
      devnet:
        ipv4_address: ${MONGO_IP}

  mongo-express:
    build:
      context: ./mongo-express
      dockerfile: Dockerfile
    image: mongo-express-ui
    pull_policy: build
    hostname: mongo-express
    environment:
      - ME_CONFIG_MONGODB_ADMINUSERNAME=${MONGO_INITDB_ROOT_USERNAME}
      - ME_CONFIG_MONGODB_ADMINPASSWORD=${MONGO_INITDB_ROOT_PASSWORD}
      - ME_CONFIG_MONGODB_SERVER=${MONGO_HOST}
      - ME_CONFIG_MONGODB_PORT=${MONGO_PORT}
      - ME_CONFIG_BASICAUTH_USERNAME=${MONGO_EXPRESS_USER}
      - ME_CONFIG_BASICAUTH_PASSWORD=${MONGO_EXPRESS_PASSWORD}
      - ME_CONFIG_SITE_BASEURL=/mongo/
    ports:
      - "${MONGO_EXPRESS_PORT}:8081"
    restart: unless-stopped
    depends_on:
      mongo:
        condition: service_healthy
    networks:
      devnet:
        ipv4_address: ${MONGO_EXPRESS_IP}

volumes:
  pgdata:
  rabbitmqdata:
  redisdata:
  kafkadata:
  cargo-cache:
  target-cache:
  prometheusdata:
  grafanadata:
  pgadmindata:
  mongodata:

networks:
  devnet:
    driver: bridge
    ipam:
      config:
        - subnet: 172.28.0.0/16